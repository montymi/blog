import{a as j,b as Lr,r as Cn}from"./react-vendor-CCVJ8uki.js";var Jn={};function Cr(e){const t=new Error(e);if(t.stack===void 0)try{throw t}catch{}return t}var Vr=Cr,I=Vr;function $r(e){return!!e&&typeof e.then=="function"}var W=$r;function Mr(e,t){if(e!=null)return e;throw I(t??"Got unexpected null or undefined")}var q=Mr;function M(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class gt{getValue(){throw I("BaseLoadable")}toPromise(){throw I("BaseLoadable")}valueMaybe(){throw I("BaseLoadable")}valueOrThrow(){throw I(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw I("BaseLoadable")}promiseOrThrow(){throw I(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw I("BaseLoadable")}errorOrThrow(){throw I(`Loadable expected error, but in "${this.state}" state`)}is(t){return t.state===this.state&&t.contents===this.contents}map(t){throw I("BaseLoadable")}}class Ir extends gt{constructor(t){super(),M(this,"state","hasValue"),M(this,"contents",void 0),this.contents=t}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(t){try{const n=t(this.contents);return W(n)?Le(n):Pe(n)?n:nt(n)}catch(n){return W(n)?Le(n.next(()=>this.map(t))):bt(n)}}}class Ur extends gt{constructor(t){super(),M(this,"state","hasError"),M(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(t){return this}}class Qn extends gt{constructor(t){super(),M(this,"state","loading"),M(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(t){return Le(this.contents.then(n=>{const o=t(n);if(Pe(o)){const r=o;switch(r.state){case"hasValue":return r.contents;case"hasError":throw r.contents;case"loading":return r.contents}}return o}).catch(n=>{if(W(n))return n.then(()=>this.map(t).contents);throw n}))}}function nt(e){return Object.freeze(new Ir(e))}function bt(e){return Object.freeze(new Ur(e))}function Le(e){return Object.freeze(new Qn(e))}function eo(){return Object.freeze(new Qn(new Promise(()=>{})))}function kr(e){return e.every(t=>t.state==="hasValue")?nt(e.map(t=>t.contents)):e.some(t=>t.state==="hasError")?bt(q(e.find(t=>t.state==="hasError"),"Invalid loadable passed to loadableAll").contents):Le(Promise.all(e.map(t=>t.contents)))}function to(e){const n=(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(r=>e[r])).map(r=>Pe(r)?r:W(r)?Le(r):nt(r)),o=kr(n);return Array.isArray(e)?o:o.map(r=>Object.getOwnPropertyNames(e).reduce((a,s,u)=>({...a,[s]:r[u]}),{}))}function Pe(e){return e instanceof gt}const Dr={of:e=>W(e)?Le(e):Pe(e)?e:nt(e),error:e=>bt(e),loading:()=>eo(),all:to,isLoadable:Pe};var Ve={loadableWithValue:nt,loadableWithError:bt,loadableWithPromise:Le,loadableLoading:eo,loadableAll:to,isLoadable:Pe,RecoilLoadable:Dr},Br=Ve.loadableWithValue,Pr=Ve.loadableWithError,Or=Ve.loadableWithPromise,Fr=Ve.loadableLoading,xr=Ve.loadableAll,zr=Ve.isLoadable,Wr=Ve.RecoilLoadable,ot=Object.freeze({__proto__:null,loadableWithValue:Br,loadableWithError:Pr,loadableWithPromise:Or,loadableLoading:Fr,loadableAll:xr,isLoadable:zr,RecoilLoadable:Wr});const Jt={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};function Gr(e,t){var n,o;const r=(n=Jn[e])===null||n===void 0||(o=n.toLowerCase())===null||o===void 0?void 0:o.trim();if(r==null||r==="")return;if(!["true","false"].includes(r))throw I(`process.env.${e} value must be 'true', 'false', or empty: ${r}`);t(r==="true")}function Kr(e,t){var n;const o=(n=Jn[e])===null||n===void 0?void 0:n.trim();o==null||o===""||t(o.split(/\s*,\s*|\s+/))}function Hr(){var e;typeof process>"u"||((e=process)===null||e===void 0?void 0:e.env)!=null&&(Gr("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",t=>{Jt.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=t}),Kr("RECOIL_GKS_ENABLED",t=>{t.forEach(n=>{Jt.RECOIL_GKS_ENABLED.add(n)})}))}Hr();var We=Jt;function Tt(e){return We.RECOIL_GKS_ENABLED.has(e)}Tt.setPass=e=>{We.RECOIL_GKS_ENABLED.add(e)};Tt.setFail=e=>{We.RECOIL_GKS_ENABLED.delete(e)};Tt.clear=()=>{We.RECOIL_GKS_ENABLED.clear()};var z=Tt;function qr(e,t,{error:n}={}){return null}var jr=qr,cn=jr,Gt,Kt,Ht;const Zr=(Gt=j.createMutableSource)!==null&&Gt!==void 0?Gt:j.unstable_createMutableSource,no=(Kt=j.useMutableSource)!==null&&Kt!==void 0?Kt:j.unstable_useMutableSource,oo=(Ht=j.useSyncExternalStore)!==null&&Ht!==void 0?Ht:j.unstable_useSyncExternalStore;function Yr(){var e;const{ReactCurrentDispatcher:t,ReactCurrentOwner:n}=j.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;return((e=t==null?void 0:t.current)!==null&&e!==void 0?e:n.currentDispatcher).useSyncExternalStore!=null}function Xr(){return z("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:z("recoil_sync_external_store")&&oo!=null?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:z("recoil_mutable_source")&&no!=null&&typeof window<"u"&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?z("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:z("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}function Jr(){return!1}var rt={createMutableSource:Zr,useMutableSource:no,useSyncExternalStore:oo,currentRendererSupportsUseSyncExternalStore:Yr,reactMode:Xr,isFastRefreshEnabled:Jr};class un{constructor(t){M(this,"key",void 0),this.key=t}toJSON(){return{key:this.key}}}class ro extends un{}class ao extends un{}function Qr(e){return e instanceof ro||e instanceof ao}var wt={AbstractRecoilValue:un,RecoilState:ro,RecoilValueReadOnly:ao,isRecoilValue:Qr},ea=wt.AbstractRecoilValue,ta=wt.RecoilState,na=wt.RecoilValueReadOnly,oa=wt.isRecoilValue,Oe=Object.freeze({__proto__:null,AbstractRecoilValue:ea,RecoilState:ta,RecoilValueReadOnly:na,isRecoilValue:oa});function ra(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()}var At=ra;class so{}const aa=new so,Ce=new Map,ln=new Map;function sa(e){return At(e,t=>q(ln.get(t)))}function ia(e){if(Ce.has(e)){const t=`Duplicate atom key "${e}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;console.warn(t)}}function ca(e){We.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&ia(e.key),Ce.set(e.key,e);const t=e.set==null?new Oe.RecoilValueReadOnly(e.key):new Oe.RecoilState(e.key);return ln.set(e.key,t),t}class io extends Error{}function ua(e){const t=Ce.get(e);if(t==null)throw new io(`Missing definition for RecoilValue: "${e}""`);return t}function la(e){return Ce.get(e)}const mt=new Map;function da(e){var t;if(!z("recoil_memory_managament_2020"))return;const n=Ce.get(e);if(n!=null&&(t=n.shouldDeleteConfigOnRelease)!==null&&t!==void 0&&t.call(n)){var o;Ce.delete(e),(o=co(e))===null||o===void 0||o(),mt.delete(e)}}function fa(e,t){z("recoil_memory_managament_2020")&&(t===void 0?mt.delete(e):mt.set(e,t))}function co(e){return mt.get(e)}var ie={nodes:Ce,recoilValues:ln,registerNode:ca,getNode:ua,getNodeMaybe:la,deleteNodeConfigIfPossible:da,setConfigDeletionHandler:fa,getConfigDeletionHandler:co,recoilValuesForKeys:sa,NodeMissingError:io,DefaultValue:so,DEFAULT_VALUE:aa};function ha(e,t){t()}var pa={enqueueExecution:ha};function _a(e,t){return t={exports:{}},e(t,t.exports),t.exports}var Sa=_a(function(e){var t=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(c){return typeof c}:function(c){return c&&typeof Symbol=="function"&&c.constructor===Symbol&&c!==Symbol.prototype?"symbol":typeof c},n={},o=5,r=Math.pow(2,o),a=r-1,s=r/2,u=r/4,l={},f=function(i){return function(){return i}},p=n.hash=function(c){var i=typeof c>"u"?"undefined":t(c);if(i==="number")return c;i!=="string"&&(c+="");for(var h=0,R=0,y=c.length;R<y;++R){var g=c.charCodeAt(R);h=(h<<5)-h+g|0}return h},S=function(i){return i-=i>>1&1431655765,i=(i&858993459)+(i>>2&858993459),i=i+(i>>4)&252645135,i+=i>>8,i+=i>>16,i&127},V=function(i,h){return h>>>i&a},C=function(i){return 1<<i},v=function(i,h){return S(i&h-1)},A=function(i,h,R,y){var g=y;if(!i){var L=y.length;g=new Array(L);for(var E=0;E<L;++E)g[E]=y[E]}return g[h]=R,g},Z=function(i,h,R){var y=R.length-1,g=0,L=0,E=R;if(i)g=L=h;else for(E=new Array(y);g<h;)E[L++]=R[g++];for(++g;g<=y;)E[L++]=R[g++];return i&&(E.length=y),E},ne=function(i,h,R,y){var g=y.length;if(i){for(var L=g;L>=h;)y[L--]=y[L];return y[h]=R,y}for(var E=0,N=0,U=new Array(g+1);E<h;)U[N++]=y[E++];for(U[h]=R;E<g;)U[++N]=y[E++];return U},w=1,B=2,J=3,x=4,G={__hamt_isEmpty:!0},Y=function(i){return i===G||i&&i.__hamt_isEmpty},re=function(i,h,R,y){return{type:w,edit:i,hash:h,key:R,value:y,_modify:Ie}},ye=function(i,h,R){return{type:B,edit:i,hash:h,children:R,_modify:Ue}},ee=function(i,h,R){return{type:J,edit:i,mask:h,children:R,_modify:P}},le=function(i,h,R){return{type:x,edit:i,size:h,children:R,_modify:O}},Me=function(i){return i===G||i.type===w||i.type===B},Q=function(i,h,R,y,g){for(var L=[],E=y,N=0,U=0;E;++U)E&1&&(L[U]=g[N++]),E>>>=1;return L[h]=R,le(i,N+1,L)},ce=function(i,h,R,y){for(var g=new Array(h-1),L=0,E=0,N=0,U=y.length;N<U;++N)if(N!==R){var H=y[N];H&&!Y(H)&&(g[L++]=H,E|=1<<N)}return ee(i,E,g)},Ae=function c(i,h,R,y,g,L){if(R===g)return ye(i,R,[L,y]);var E=V(h,R),N=V(h,g);return ee(i,C(E)|C(N),E===N?[c(i,h+o,R,y,g,L)]:E<N?[y,L]:[L,y])},de=function(i,h,R,y,g,L,E,N){for(var U=g.length,H=0;H<U;++H){var ae=g[H];if(R(E,ae.key)){var oe=ae.value,he=L(oe);return he===oe?g:he===l?(--N.value,Z(i,H,g)):A(i,H,re(h,y,E,he),g)}}var _e=L();return _e===l?g:(++N.value,A(i,U,re(h,y,E,_e),g))},ve=function(i,h){return i===h.edit},Ie=function(i,h,R,y,g,L,E){if(h(L,this.key)){var N=y(this.value);return N===this.value?this:N===l?(--E.value,G):ve(i,this)?(this.value=N,this):re(i,g,L,N)}var U=y();return U===l?this:(++E.value,Ae(i,R,this.hash,this,g,re(i,g,L,U)))},Ue=function(i,h,R,y,g,L,E){if(g===this.hash){var N=ve(i,this),U=de(N,i,h,this.hash,this.children,y,L,E);return U===this.children?this:U.length>1?ye(i,this.hash,U):U[0]}var H=y();return H===l?this:(++E.value,Ae(i,R,this.hash,this,g,re(i,g,L,H)))},P=function(i,h,R,y,g,L,E){var N=this.mask,U=this.children,H=V(R,g),ae=C(H),oe=v(N,ae),he=N&ae,_e=he?U[oe]:G,ke=_e._modify(i,h,R+o,y,g,L,E);if(_e===ke)return this;var ut=ve(i,this),Ke=N,He=void 0;if(he&&Y(ke)){if(Ke&=~ae,!Ke)return G;if(U.length<=2&&Me(U[oe^1]))return U[oe^1];He=Z(ut,oe,U)}else if(!he&&!Y(ke)){if(U.length>=s)return Q(i,H,ke,N,U);Ke|=ae,He=ne(ut,oe,ke,U)}else He=A(ut,oe,ke,U);return ut?(this.mask=Ke,this.children=He,this):ee(i,Ke,He)},O=function(i,h,R,y,g,L,E){var N=this.size,U=this.children,H=V(R,g),ae=U[H],oe=(ae||G)._modify(i,h,R+o,y,g,L,E);if(ae===oe)return this;var he=ve(i,this),_e=void 0;if(Y(ae)&&!Y(oe))++N,_e=A(he,H,oe,U);else if(!Y(ae)&&Y(oe)){if(--N,N<=u)return ce(i,N,H,U);_e=A(he,H,G,U)}else _e=A(he,H,oe,U);return he?(this.size=N,this.children=_e,this):le(i,N,_e)};G._modify=function(c,i,h,R,y,g,L){var E=R();return E===l?G:(++L.value,re(c,y,g,E))};function d(c,i,h,R,y){this._editable=c,this._edit=i,this._config=h,this._root=R,this._size=y}d.prototype.setTree=function(c,i){return this._editable?(this._root=c,this._size=i,this):c===this._root?this:new d(this._editable,this._edit,this._config,c,i)};var _=n.tryGetHash=function(c,i,h,R){for(var y=R._root,g=0,L=R._config.keyEq;;)switch(y.type){case w:return L(h,y.key)?y.value:c;case B:{if(i===y.hash)for(var E=y.children,N=0,U=E.length;N<U;++N){var H=E[N];if(L(h,H.key))return H.value}return c}case J:{var ae=V(g,i),oe=C(ae);if(y.mask&oe){y=y.children[v(y.mask,oe)],g+=o;break}return c}case x:{if(y=y.children[V(g,i)],y){g+=o;break}return c}default:return c}};d.prototype.tryGetHash=function(c,i,h){return _(c,i,h,this)};var m=n.tryGet=function(c,i,h){return _(c,h._config.hash(i),i,h)};d.prototype.tryGet=function(c,i){return m(c,i,this)};var $=n.getHash=function(c,i,h){return _(void 0,c,i,h)};d.prototype.getHash=function(c,i){return $(c,i,this)},n.get=function(c,i){return _(void 0,i._config.hash(c),c,i)},d.prototype.get=function(c,i){return m(i,c,this)};var b=n.has=function(c,i,h){return _(l,c,i,h)!==l};d.prototype.hasHash=function(c,i){return b(c,i,this)};var D=n.has=function(c,i){return b(i._config.hash(c),c,i)};d.prototype.has=function(c){return D(c,this)};var k=function(i,h){return i===h};n.make=function(c){return new d(0,0,{keyEq:c&&c.keyEq||k,hash:c&&c.hash||p},G,0)},n.empty=n.make();var T=n.isEmpty=function(c){return c&&!!Y(c._root)};d.prototype.isEmpty=function(){return T(this)};var K=n.modifyHash=function(c,i,h,R){var y={value:R._size},g=R._root._modify(R._editable?R._edit:NaN,R._config.keyEq,0,c,i,h,y);return R.setTree(g,y.value)};d.prototype.modifyHash=function(c,i,h){return K(h,c,i,this)};var te=n.modify=function(c,i,h){return K(c,h._config.hash(i),i,h)};d.prototype.modify=function(c,i){return te(i,c,this)};var F=n.setHash=function(c,i,h,R){return K(f(h),c,i,R)};d.prototype.setHash=function(c,i,h){return F(c,i,h,this)};var X=n.set=function(c,i,h){return F(h._config.hash(c),c,i,h)};d.prototype.set=function(c,i){return X(c,i,this)};var pe=f(l),Ee=n.removeHash=function(c,i,h){return K(pe,c,i,h)};d.prototype.removeHash=d.prototype.deleteHash=function(c,i){return Ee(c,i,this)};var fe=n.remove=function(c,i){return Ee(i._config.hash(c),c,i)};d.prototype.remove=d.prototype.delete=function(c){return fe(c,this)};var ue=n.beginMutation=function(c){return new d(c._editable+1,c._edit+1,c._config,c._root,c._size)};d.prototype.beginMutation=function(){return ue(this)};var An=n.endMutation=function(c){return c._editable=c._editable&&c._editable-1,c};d.prototype.endMutation=function(){return An(this)};var Rr=n.mutate=function(c,i){var h=ue(i);return c(h),An(h)};d.prototype.mutate=function(c){return Rr(c,this)};var xt=function(i){return i&&En(i[0],i[1],i[2],i[3],i[4])},En=function(i,h,R,y,g){for(;R<i;){var L=h[R++];if(L&&!Y(L))return Nn(L,y,[i,h,R,y,g])}return xt(g)},Nn=function(i,h,R){switch(i.type){case w:return{value:h(i),rest:R};case B:case x:case J:var y=i.children;return En(y.length,y,0,h,R);default:return xt(R)}},yr={done:!0};function zt(c){this.v=c}zt.prototype.next=function(){if(!this.v)return yr;var c=this.v;return this.v=xt(c.rest),c},zt.prototype[Symbol.iterator]=function(){return this};var Wt=function(i,h){return new zt(Nn(i._root,h))},vr=function(i){return[i.key,i.value]},gr=n.entries=function(c){return Wt(c,vr)};d.prototype.entries=d.prototype[Symbol.iterator]=function(){return gr(this)};var br=function(i){return i.key},Tr=n.keys=function(c){return Wt(c,br)};d.prototype.keys=function(){return Tr(this)};var wr=function(i){return i.value},Ar=n.values=d.prototype.values=function(c){return Wt(c,wr)};d.prototype.values=function(){return Ar(this)};var Ln=n.fold=function(c,i,h){var R=h._root;if(R.type===w)return c(i,R.value,R.key);for(var y=[R.children],g=void 0;g=y.pop();)for(var L=0,E=g.length;L<E;){var N=g[L++];N&&N.type&&(N.type===w?i=c(i,N.value,N.key):y.push(N.children))}return i};d.prototype.fold=function(c,i){return Ln(c,i,this)};var Er=n.forEach=function(c,i){return Ln(function(h,R,y){return c(R,y,i)},null,i)};d.prototype.forEach=function(c){return Er(c,this)};var Nr=n.count=function(c){return c._size};d.prototype.count=function(){return Nr(this)},Object.defineProperty(d.prototype,"size",{get:d.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n});class ma{constructor(t){M(this,"_map",void 0),this._map=new Map(t==null?void 0:t.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(t){return this._map.get(t)}has(t){return this._map.has(t)}set(t,n){return this._map.set(t,n),this}delete(t){return this._map.delete(t),this}clone(){return fn(this)}toMap(){return new Map(this._map)}}class dn{constructor(t){if(M(this,"_hamt",Sa.empty.beginMutation()),t instanceof dn){const n=t._hamt.endMutation();t._hamt=n.beginMutation(),this._hamt=n.beginMutation()}else if(t)for(const[n,o]of t.entries())this._hamt.set(n,o)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(t){return this._hamt.get(t)}has(t){return this._hamt.has(t)}set(t,n){return this._hamt.set(t,n),this}delete(t){return this._hamt.delete(t),this}clone(){return fn(this)}toMap(){return new Map(this._hamt)}}function fn(e){return z("recoil_hamt_2020")?new dn(e):new ma(e)}var Ra={persistentMap:fn},ya=Ra.persistentMap,va=Object.freeze({__proto__:null,persistentMap:ya});function ga(e,...t){const n=new Set;e:for(const o of e){for(const r of t)if(r.has(o))continue e;n.add(o)}return n}var Qe=ga;function ba(e,t){const n=new Map;return e.forEach((o,r)=>{n.set(r,t(o,r))}),n}var Rt=ba;function Ta(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}}function wa(e){return{nodeDeps:Rt(e.nodeDeps,t=>new Set(t)),nodeToNodeSubscriptions:Rt(e.nodeToNodeSubscriptions,t=>new Set(t))}}function qt(e,t,n,o){const{nodeDeps:r,nodeToNodeSubscriptions:a}=n,s=r.get(e);if(s&&o&&s!==o.nodeDeps.get(e))return;r.set(e,t);const u=s==null?t:Qe(t,s);for(const l of u)a.has(l)||a.set(l,new Set),q(a.get(l)).add(e);if(s){const l=Qe(s,t);for(const f of l){if(!a.has(f))return;const p=q(a.get(f));p.delete(e),p.size===0&&a.delete(f)}}}function Aa(e,t,n,o){var r,a,s,u;const l=n.getState();o===l.currentTree.version||o===((r=l.nextTree)===null||r===void 0?void 0:r.version)||((a=l.previousTree)===null||a===void 0||a.version);const f=n.getGraph(o);if(qt(e,t,f),o===((s=l.previousTree)===null||s===void 0?void 0:s.version)){const S=n.getGraph(l.currentTree.version);qt(e,t,S,f)}if(o===((u=l.previousTree)===null||u===void 0?void 0:u.version)||o===l.currentTree.version){var p;const S=(p=l.nextTree)===null||p===void 0?void 0:p.version;if(S!==void 0){const V=n.getGraph(S);qt(e,t,V,f)}}}var at={cloneGraph:wa,graph:Ta,saveDepsToStore:Aa};let Ea=0;const Na=()=>Ea++;let La=0;const Ca=()=>La++;let Va=0;const $a=()=>Va++;var Et={getNextTreeStateVersion:Na,getNextStoreID:Ca,getNextComponentID:$a};const{persistentMap:Vn}=va,{graph:Ma}=at,{getNextTreeStateVersion:uo}=Et;function lo(){const e=uo();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:Vn(),nonvalidatedAtoms:Vn()}}function Ia(){const e=lo();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,Ma()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var fo={makeEmptyTreeState:lo,makeEmptyStoreState:Ia,getNextTreeStateVersion:uo};class ho{}function Ua(){return new ho}var Nt={RetentionZone:ho,retentionZone:Ua};function ka(e,t){const n=new Set(e);return n.add(t),n}function Da(e,t){const n=new Set(e);return n.delete(t),n}function Ba(e,t,n){const o=new Map(e);return o.set(t,n),o}function Pa(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o}function Oa(e,t){const n=new Map(e);return n.delete(t),n}function Fa(e,t){const n=new Map(e);return t.forEach(o=>n.delete(o)),n}var po={setByAddingToSet:ka,setByDeletingFromSet:Da,mapBySettingInMap:Ba,mapByUpdatingInMap:Pa,mapByDeletingFromMap:Oa,mapByDeletingMultipleFromMap:Fa};function*xa(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)}var hn=xa;function za(e,t){return new Proxy(e,{get:(o,r)=>(!(r in o)&&r in t&&(o[r]=t[r]()),o[r]),ownKeys:o=>Object.keys(o)})}var _o=za;const{getNode:st,getNodeMaybe:Wa,recoilValuesForKeys:$n}=ie,{RetentionZone:Mn}=Nt,{setByAddingToSet:Ga}=po,Ka=Object.freeze(new Set);class Ha extends Error{}function qa(e,t,n){if(!z("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(a){let s=o.get(a);s||o.set(a,s=new Set),s.add(t)}if(n instanceof Mn)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!z("recoil_memory_managament_2020"))return;const{retention:a}=e.getState();function s(u){const l=a.nodesRetainedByZone.get(u);l==null||l.delete(t),l&&l.size===0&&a.nodesRetainedByZone.delete(u)}if(n instanceof Mn)s(n);else if(Array.isArray(n))for(const u of n)s(u)}}function pn(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=st(n),s=qa(e,n,a.retainedBy),u=a.init(e,t,o);r.nodeCleanupFunctions.set(n,()=>{u(),s()})}function ja(e,t,n){pn(e,e.getState().currentTree,t,n)}function Za(e,t){var n;const o=e.getState();(n=o.nodeCleanupFunctions.get(t))===null||n===void 0||n(),o.nodeCleanupFunctions.delete(t)}function Ya(e,t,n){return pn(e,t,n,"get"),st(n).get(e,t)}function So(e,t,n){return st(n).peek(e,t)}function Xa(e,t,n){var o;const r=Wa(t);return r==null||(o=r.invalidate)===null||o===void 0||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:Ga(e.dirtyAtoms,t)}}function Ja(e,t,n,o){const r=st(n);if(r.set==null)throw new Ha(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return pn(e,t,n,"set"),a(e,t,o)}function Qa(e,t,n){const o=e.getState(),r=e.getGraph(t.version),a=st(n).nodeType;return _o({type:a},{loadable:()=>So(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>a==="selector"?!1:t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var s;return $n((s=r.nodeDeps.get(n))!==null&&s!==void 0?s:[])},subscribers:()=>{var s,u;return{nodes:$n(hn(mo(e,t,new Set([n])),l=>l!==n)),components:At((s=(u=o.nodeToComponentSubscriptions.get(n))===null||u===void 0?void 0:u.values())!==null&&s!==void 0?s:[],([l])=>({name:l}))}}})}function mo(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let u=r.pop();u;u=r.pop()){var s;o.add(u);const l=(s=a.nodeToNodeSubscriptions.get(u))!==null&&s!==void 0?s:Ka;for(const f of l)o.has(f)||r.push(f)}return o}var Te={getNodeLoadable:Ya,peekNodeLoadable:So,setNodeValue:Ja,initializeNode:ja,cleanUpNode:Za,setUnvalidatedAtomValue_DEPRECATED:Xa,peekNodeInfo:Qa,getDownstreamNodes:mo};let Ro=null;function es(e){Ro=e}function ts(){var e;(e=Ro)===null||e===void 0||e()}var yo={setInvalidateMemoizedSnapshot:es,invalidateMemoizedSnapshot:ts};const{getDownstreamNodes:ns,getNodeLoadable:vo,setNodeValue:os}=Te,{getNextComponentID:rs}=Et,{getNode:as,getNodeMaybe:go}=ie,{DefaultValue:_n}=ie,{reactMode:ss}=rt,{AbstractRecoilValue:is,RecoilState:cs,RecoilValueReadOnly:us,isRecoilValue:ls}=Oe,{invalidateMemoizedSnapshot:ds}=yo;function fs(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version===a.currentTree.version||n.version===((o=a.nextTree)===null||o===void 0?void 0:o.version)||(n.version,(r=a.previousTree)===null||r===void 0||r.version);const s=vo(e,n,t);return s.state==="loading"&&s.contents.catch(()=>{}),s}function hs(e,t){const n=e.clone();return t.forEach((o,r)=>{o.state==="hasValue"&&o.contents instanceof _n?n.delete(r):n.set(r,o)}),n}function ps(e,t,{key:n},o){if(typeof o=="function"){const r=vo(e,t,n);if(r.state==="loading"){const a=`Tried to set atom or selector "${n}" using an updater function while the current state is pending, this is not currently supported.`;throw I(a)}else if(r.state==="hasError")throw r.contents;return o(r.contents)}else return o}function _s(e,t,n){if(n.type==="set"){const{recoilValue:r,valueOrUpdater:a}=n,s=ps(e,t,r,a),u=os(e,t,r.key,s);for(const[l,f]of u.entries())Qt(t,l,f)}else if(n.type==="setLoadable"){const{recoilValue:{key:r},loadable:a}=n;Qt(t,r,a)}else if(n.type==="markModified"){const{recoilValue:{key:r}}=n;t.dirtyAtoms.add(r)}else if(n.type==="setUnvalidated"){var o;const{recoilValue:{key:r},unvalidatedValue:a}=n,s=go(r);s==null||(o=s.invalidate)===null||o===void 0||o.call(s,t),t.atomValues.delete(r),t.nonvalidatedAtoms.set(r,a),t.dirtyAtoms.add(r)}else cn(`Unknown action ${n.type}`)}function Qt(e,t,n){n.state==="hasValue"&&n.contents instanceof _n?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function bo(e,t){e.replaceState(n=>{const o=To(n);for(const r of t)_s(e,o,r);return wo(e,o),ds(),o})}function Lt(e,t){if(et.length){const n=et[et.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else bo(e,[t])}const et=[];function Ss(){const e=new Map;return et.push(e),()=>{for(const[t,n]of e)bo(t,n);et.pop()}}function To(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function wo(e,t){const n=ns(e,t,t.dirtyAtoms);for(const a of n){var o,r;(o=go(a))===null||o===void 0||(r=o.invalidate)===null||r===void 0||r.call(o,t)}}function Ao(e,t,n){Lt(e,{type:"set",recoilValue:t,valueOrUpdater:n})}function ms(e,t,n){if(n instanceof _n)return Ao(e,t,n);Lt(e,{type:"setLoadable",recoilValue:t,loadable:n})}function Rs(e,t){Lt(e,{type:"markModified",recoilValue:t})}function ys(e,t,n){Lt(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})}function vs(e,{key:t},n,o=null){const r=rs(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),q(a.nodeToComponentSubscriptions.get(t)).set(r,[o??"<not captured>",n]);const s=ss();if(s.early&&(s.mode==="LEGACY"||s.mode==="MUTABLE_SOURCE")){const u=e.getState().nextTree;u&&u.dirtyAtoms.has(t)&&n(u)}return{release:()=>{const u=e.getState(),l=u.nodeToComponentSubscriptions.get(t);l===void 0||!l.has(r)||(l.delete(r),l.size===0&&u.nodeToComponentSubscriptions.delete(t))}}}function gs(e,t){var n;const{currentTree:o}=e.getState(),r=as(t.key);(n=r.clearCache)===null||n===void 0||n.call(r,e,o)}var me={RecoilValueReadOnly:us,AbstractRecoilValue:is,RecoilState:cs,getRecoilValueAsLoadable:fs,setRecoilValue:Ao,setRecoilValueLoadable:ms,markRecoilValueModified:Rs,setUnvalidatedRecoilValue:ys,subscribeToRecoilValue:vs,isRecoilValue:ls,applyAtomValueWrites:hs,batchStart:Ss,writeLoadableToTreeState:Qt,invalidateDownstreams:wo,copyTreeState:To,refreshRecoilValue:gs};function bs(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1}var Ts=bs;const{cleanUpNode:ws}=Te,{deleteNodeConfigIfPossible:As,getNode:Eo}=ie,{RetentionZone:No}=Nt,Es=12e4,Lo=new Set;function Co(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return;const r=new Set;for(const s of t)if(s instanceof No)for(const u of Vs(n,s))r.add(u);else r.add(s);const a=Ns(e,r);for(const s of a)Cs(e,o,s)}function Ns(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,s=new Set;return u(t),a;function u(l){const f=new Set,p=Ls(e,o,l,a,s);for(const v of p){var S;if(Eo(v).retainedBy==="recoilRoot"){s.add(v);continue}if(((S=n.retention.referenceCounts.get(v))!==null&&S!==void 0?S:0)>0){s.add(v);continue}if(Vo(v).some(Z=>n.retention.referenceCounts.get(Z))){s.add(v);continue}const A=r.nodeToNodeSubscriptions.get(v);if(A&&Ts(A,Z=>s.has(Z))){s.add(v);continue}a.add(v),f.add(v)}const V=new Set;for(const v of f)for(const A of(C=r.nodeDeps.get(v))!==null&&C!==void 0?C:Lo){var C;a.has(A)||V.add(A)}V.size&&u(V)}}function Ls(e,t,n,o,r){const a=e.getGraph(t.version),s=[],u=new Set;for(;n.size>0;)l(q(n.values().next().value));return s;function l(f){if(o.has(f)||r.has(f)){n.delete(f);return}if(u.has(f))return;const p=a.nodeToNodeSubscriptions.get(f);if(p)for(const S of p)l(S);u.add(f),n.delete(f),s.push(f)}}function Cs(e,t,n){if(!z("recoil_memory_managament_2020"))return;ws(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=Vo(n);for(const l of r){var a;(a=o.retention.nodesRetainedByZone.get(l))===null||a===void 0||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const s=o.graphsByVersion.get(t.version);if(s){const l=s.nodeDeps.get(n);if(l!==void 0){s.nodeDeps.delete(n);for(const f of l){var u;(u=s.nodeToNodeSubscriptions.get(f))===null||u===void 0||u.delete(n)}}s.nodeToNodeSubscriptions.delete(n)}As(n)}function Vs(e,t){var n;return(n=e.retention.nodesRetainedByZone.get(t))!==null&&n!==void 0?n:Lo}function Vo(e){const t=Eo(e).retainedBy;return t===void 0||t==="components"||t==="recoilRoot"?[]:t instanceof No?[t]:t}function $s(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):Co(e,new Set([t]))}function Ms(e,t,n){var o;if(!z("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=((o=r.get(t))!==null&&o!==void 0?o:0)+n;a===0?$o(e,t):r.set(t,a)}function $o(e,t){if(!z("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),$s(e,t)}function Is(e){if(!z("recoil_memory_managament_2020"))return;const t=e.getState();Co(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()}function Us(e){return e===void 0?"recoilRoot":e}var $e={SUSPENSE_TIMEOUT_MS:Es,updateRetainCount:Ms,updateRetainCountToZero:$o,releaseScheduledRetainablesNow:Is,retainedByOptionWithDefault:Us};const{unstable_batchedUpdates:ks}=Lr;var Ds={unstable_batchedUpdates:ks};const{unstable_batchedUpdates:Bs}=Ds;var Ps={unstable_batchedUpdates:Bs};const{batchStart:Os}=me,{unstable_batchedUpdates:Fs}=Ps;let Sn=Fs||(e=>e());const xs=e=>{Sn=e},zs=()=>Sn,Ws=e=>{Sn(()=>{let t=()=>{};try{t=Os(),e()}finally{t()}})};var Ct={getBatcher:zs,setBatcher:xs,batchUpdates:Ws};function*Gs(e){for(const t of e)for(const n of t)yield n}var Mo=Gs;const Io=typeof Window>"u"||typeof window>"u",Ks=e=>!Io&&(e===window||e instanceof Window),Hs=typeof navigator<"u"&&navigator.product==="ReactNative";var Vt={isSSR:Io,isReactNative:Hs,isWindow:Ks};function qs(e,t){let n;return(...o)=>{n||(n={});const r=t(...o);return Object.hasOwnProperty.call(n,r)||(n[r]=e(...o)),n[r]}}function js(e,t){let n,o;return(...r)=>{const a=t(...r);return n===a||(n=a,o=e(...r)),o}}function Zs(e,t){let n,o;return[(...s)=>{const u=t(...s);return n===u||(n=u,o=e(...s)),o},()=>{n=null}]}var Ys={memoizeWithArgsHash:qs,memoizeOneWithArgsHash:js,memoizeOneWithArgsHashAndInvalidation:Zs};const{batchUpdates:en}=Ct,{initializeNode:Xs,peekNodeInfo:Js}=Te,{graph:Qs}=at,{getNextStoreID:ei}=Et,{DEFAULT_VALUE:ti,recoilValues:In,recoilValuesForKeys:Un}=ie,{AbstractRecoilValue:ni,getRecoilValueAsLoadable:oi,setRecoilValue:kn,setUnvalidatedRecoilValue:ri}=me,{updateRetainCount:_t}=$e,{setInvalidateMemoizedSnapshot:ai}=yo,{getNextTreeStateVersion:si,makeEmptyStoreState:ii}=fo,{isSSR:ci}=Vt,{memoizeOneWithArgsHashAndInvalidation:ui}=Ys;class $t{constructor(t,n){M(this,"_store",void 0),M(this,"_refCount",1),M(this,"getLoadable",o=>(this.checkRefCount_INTERNAL(),oi(this._store,o))),M(this,"getPromise",o=>(this.checkRefCount_INTERNAL(),this.getLoadable(o).toPromise())),M(this,"getNodes_UNSTABLE",o=>{if(this.checkRefCount_INTERNAL(),(o==null?void 0:o.isModified)===!0){if((o==null?void 0:o.isInitialized)===!1)return[];const s=this._store.getState().currentTree;return Un(s.dirtyAtoms)}const r=this._store.getState().knownAtoms,a=this._store.getState().knownSelectors;return(o==null?void 0:o.isInitialized)==null?In.values():o.isInitialized===!0?Un(Mo([r,a])):hn(In.values(),({key:s})=>!r.has(s)&&!a.has(s))}),M(this,"getInfo_UNSTABLE",({key:o})=>(this.checkRefCount_INTERNAL(),Js(this._store,this._store.getState().currentTree,o))),M(this,"map",o=>{this.checkRefCount_INTERNAL();const r=new tn(this,en);return o(r),r}),M(this,"asyncMap",async o=>{this.checkRefCount_INTERNAL();const r=new tn(this,en);return r.retain(),await o(r),r.autoRelease_INTERNAL(),r}),this._store={storeID:ei(),parentStoreID:n,getState:()=>t,replaceState:o=>{t.currentTree=o(t.currentTree)},getGraph:o=>{const r=t.graphsByVersion;if(r.has(o))return q(r.get(o));const a=Qs();return r.set(o,a),a},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw I("Cannot subscribe to Snapshots")}};for(const o of this._store.getState().knownAtoms)Xs(this._store,o,"get"),_t(this._store,o,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0,this._refCount++;let t=!1;return()=>{t||(t=!0,this._release())}}autoRelease_INTERNAL(){ci||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,this._refCount===0){if(this._store.getState().nodeCleanupFunctions.forEach(t=>t()),this._store.getState().nodeCleanupFunctions.clear(),!z("recoil_memory_managament_2020"))return}else this._refCount<0}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){z("recoil_memory_managament_2020")&&this._refCount<=0}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}}function Uo(e,t,n=!1){const o=e.getState(),r=n?si():t.version;return{currentTree:{version:n?r:t.version,stateID:n?r:t.stateID,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(At(o.nodeCleanupFunctions.entries(),([a])=>[a,()=>{}]))}}function li(e){const t=new $t(ii());return e!=null?t.map(e):t}const[Dn,ko]=ui((e,t)=>{var n;const o=e.getState(),r=t==="latest"?(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree:q(o.previousTree);return new $t(Uo(e,r),e.storeID)},(e,t)=>{var n,o;return String(t)+String(e.storeID)+String((n=e.getState().nextTree)===null||n===void 0?void 0:n.version)+String(e.getState().currentTree.version)+String((o=e.getState().previousTree)===null||o===void 0?void 0:o.version)});ai(ko);function di(e,t="latest"){const n=Dn(e,t);return n.isRetained()?n:(ko(),Dn(e,t))}class tn extends $t{constructor(t,n){super(Uo(t.getStore_INTERNAL(),t.getStore_INTERNAL().getState().currentTree,!0),t.getStoreID()),M(this,"_batch",void 0),M(this,"set",(o,r)=>{this.checkRefCount_INTERNAL();const a=this.getStore_INTERNAL();this._batch(()=>{_t(a,o.key,1),kn(this.getStore_INTERNAL(),o,r)})}),M(this,"reset",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();this._batch(()=>{_t(r,o.key,1),kn(this.getStore_INTERNAL(),o,ti)})}),M(this,"setUnvalidatedAtomValues_DEPRECATED",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();en(()=>{for(const[a,s]of o.entries())_t(r,a,1),ri(r,new ni(a),s)})}),this._batch=n}}var Mt={Snapshot:$t,MutableSnapshot:tn,freshSnapshot:li,cloneSnapshot:di},fi=Mt.Snapshot,hi=Mt.MutableSnapshot,pi=Mt.freshSnapshot,_i=Mt.cloneSnapshot,It=Object.freeze({__proto__:null,Snapshot:fi,MutableSnapshot:hi,freshSnapshot:pi,cloneSnapshot:_i});function Si(...e){const t=new Set;for(const n of e)for(const o of n)t.add(o);return t}var mi=Si;const{useRef:Ri}=j;function yi(e){const t=Ri(e);return t.current===e&&typeof e=="function"&&(t.current=e()),t}var Bn=yi;const{getNextTreeStateVersion:vi,makeEmptyStoreState:Do}=fo,{cleanUpNode:gi,getDownstreamNodes:bi,initializeNode:Ti,setNodeValue:wi,setUnvalidatedAtomValue_DEPRECATED:Ai}=Te,{graph:Ei}=at,{cloneGraph:Ni}=at,{getNextStoreID:Bo}=Et,{createMutableSource:jt,reactMode:Po}=rt,{applyAtomValueWrites:Li}=me,{releaseScheduledRetainablesNow:Oo}=$e,{freshSnapshot:Ci}=It,{useCallback:Vi,useContext:Fo,useEffect:nn,useMemo:$i,useRef:Mi,useState:Ii}=j;function qe(){throw I("This component must be used inside a <RecoilRoot> component.")}const xo=Object.freeze({storeID:Bo(),getState:qe,replaceState:qe,getGraph:qe,subscribeToTransactions:qe,addTransactionMetadata:qe});let on=!1;function Pn(e){if(on)throw I("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(t.nextTree===null){z("recoil_memory_managament_2020")&&z("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&Oo(e);const n=t.currentTree.version,o=vi();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,Ni(q(t.graphsByVersion.get(n))))}}const zo=j.createContext({current:xo}),Ut=()=>Fo(zo),Wo=j.createContext(null);function Ui(){return Fo(Wo)}function mn(e,t,n){const o=bi(e,n,n.dirtyAtoms);for(const r of o){const a=t.nodeToComponentSubscriptions.get(r);if(a)for(const[s,[u,l]]of a)l(n)}}function Go(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[r,a]of t.nodeTransactionSubscriptions)if(o.has(r))for(const[s,u]of a)u(e);for(const[r,a]of t.transactionSubscriptions)a(e);(!Po().early||t.suspendedComponentResolvers.size>0)&&(mn(e,t,n),t.suspendedComponentResolvers.forEach(r=>r()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(r=>r(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function ki(e){const t=e.getState();t.commitDepth++;try{const{nextTree:n}=t;if(n==null)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,Go(e),t.previousTree!=null?t.graphsByVersion.delete(t.previousTree.version):cn("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,z("recoil_memory_managament_2020")&&n==null&&Oo(e)}finally{t.commitDepth--}}function Di({setNotifyBatcherOfChange:e}){const t=Ut(),[,n]=Ii([]);return e(()=>n({})),nn(()=>(e(()=>n({})),()=>{e(()=>{})}),[e]),nn(()=>{pa.enqueueExecution("Batcher",()=>{ki(t.current)})}),null}function Bi(e,t){const n=Do();return t({set:(o,r)=>{const a=n.currentTree,s=wi(e,a,o.key,r),u=new Set(s.keys()),l=a.nonvalidatedAtoms.clone();for(const f of u)l.delete(f);n.currentTree={...a,dirtyAtoms:mi(a.dirtyAtoms,u),atomValues:Li(a.atomValues,s),nonvalidatedAtoms:l}},setUnvalidatedAtomValues:o=>{o.forEach((r,a)=>{n.currentTree=Ai(n.currentTree,a,r)})}}),n}function Pi(e){const t=Ci(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach(o=>o()),n.nodeCleanupFunctions.clear(),n}let On=0;function Oi({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){let r;const a=C=>{const v=r.current.graphsByVersion;if(v.has(C))return q(v.get(C));const A=Ei();return v.set(C,A),A},s=(C,v)=>{if(v==null){const{transactionSubscriptions:A}=S.current.getState(),Z=On++;return A.set(Z,C),{release:()=>{A.delete(Z)}}}else{const{nodeTransactionSubscriptions:A}=S.current.getState();A.has(v)||A.set(v,new Map);const Z=On++;return q(A.get(v)).set(Z,C),{release:()=>{const ne=A.get(v);ne&&(ne.delete(Z),ne.size===0&&A.delete(v))}}}},u=C=>{Pn(S.current);for(const v of Object.keys(C))q(S.current.getState().nextTree).transactionMetadata[v]=C[v]},l=C=>{Pn(S.current);const v=q(r.current.nextTree);let A;try{on=!0,A=C(v)}finally{on=!1}A!==v&&(r.current.nextTree=A,Po().early&&mn(S.current,r.current,A),q(f.current)())},f=Mi(null),p=Vi(C=>{f.current=C},[f]),S=Bn(()=>n??{storeID:Bo(),getState:()=>r.current,replaceState:l,getGraph:a,subscribeToTransactions:s,addTransactionMetadata:u});n!=null&&(S.current=n),r=Bn(()=>e!=null?Bi(S.current,e):t!=null?Pi(t):Do());const V=$i(()=>jt==null?void 0:jt(r,()=>r.current.currentTree.version),[r]);return nn(()=>{const C=S.current;for(const v of new Set(C.getState().knownAtoms))Ti(C,v,"get");return()=>{for(const v of C.getState().knownAtoms)gi(C,v)}},[S]),j.createElement(zo.Provider,{value:S},j.createElement(Wo.Provider,{value:V},j.createElement(Di,{setNotifyBatcherOfChange:p}),o))}function Fi(e){const{override:t,...n}=e,o=Ut();return t===!1&&o.current!==xo?e.children:j.createElement(Oi,n)}function xi(){return Ut().current.storeID}var ge={RecoilRoot:Fi,useStoreRef:Ut,useRecoilMutableSource:Ui,useRecoilStoreID:xi,notifyComponents_FOR_TESTING:mn,sendEndOfBatchNotifications_FOR_TESTING:Go};function zi(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}var Wi=zi;const{useEffect:Gi,useRef:Ki}=j;function Hi(e){const t=Ki();return Gi(()=>{t.current=e}),t.current}var Ko=Hi;const{useStoreRef:qi}=ge,{SUSPENSE_TIMEOUT_MS:ji}=$e,{updateRetainCount:je}=$e,{RetentionZone:Zi}=Nt,{useEffect:Yi,useRef:Xi}=j,{isSSR:Fn}=Vt;function Ji(e){if(z("recoil_memory_managament_2020"))return Qi(e)}function Qi(e){const n=(Array.isArray(e)?e:[e]).map(s=>s instanceof Zi?s:s.key),o=qi();Yi(()=>{if(!z("recoil_memory_managament_2020"))return;const s=o.current;if(r.current&&!Fn)window.clearTimeout(r.current),r.current=null;else for(const u of n)je(s,u,1);return()=>{for(const u of n)je(s,u,-1)}},[o,...n]);const r=Xi(),a=Ko(n);if(!Fn&&(a===void 0||!Wi(a,n))){const s=o.current;for(const u of n)je(s,u,1);if(a)for(const u of a)je(s,u,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{r.current=null;for(const u of n)je(s,u,-1)},ji)}}var Rn=Ji;function ec(){return"<component name not available>"}var it=ec;const{batchUpdates:tc}=Ct,{DEFAULT_VALUE:Ho}=ie,{currentRendererSupportsUseSyncExternalStore:nc,reactMode:Ge,useMutableSource:oc,useSyncExternalStore:rc}=rt,{useRecoilMutableSource:ac,useStoreRef:Re}=ge,{AbstractRecoilValue:rn,getRecoilValueAsLoadable:ct,setRecoilValue:yt,setUnvalidatedRecoilValue:sc,subscribeToRecoilValue:Fe}=me,{useCallback:se,useEffect:xe,useMemo:qo,useRef:tt,useState:yn}=j,{setByAddingToSet:ic}=po,{isSSR:cc}=Vt;function vn(e,t,n){if(e.state==="hasValue")return e.contents;throw e.state==="loading"?new Promise(r=>{const a=n.current.getState().suspendedComponentResolvers;a.add(r),cc&&W(e.contents)&&e.contents.finally(()=>{a.delete(r)})}):e.state==="hasError"?e.contents:I(`Invalid value of loadable atom "${t.key}"`)}function uc(){const e=it(),t=Re(),[,n]=yn([]),o=tt(new Set);o.current=new Set;const r=tt(new Set),a=tt(new Map),s=se(l=>{const f=a.current.get(l);f&&(f.release(),a.current.delete(l))},[a]),u=se((l,f)=>{a.current.has(f)&&n([])},[]);return xe(()=>{const l=t.current;Qe(o.current,r.current).forEach(f=>{if(a.current.has(f))return;const p=Fe(l,new rn(f),V=>u(V,f),e);a.current.set(f,p),l.getState().nextTree?l.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{u(l.getState(),f)}):u(l.getState(),f)}),Qe(r.current,o.current).forEach(f=>{s(f)}),r.current=o.current}),xe(()=>{const l=a.current;return Qe(o.current,new Set(l.keys())).forEach(f=>{const p=Fe(t.current,new rn(f),S=>u(S,f),e);l.set(f,p)}),()=>l.forEach((f,p)=>s(p))},[e,t,s,u]),qo(()=>{function l(v){return A=>{yt(t.current,v,A)}}function f(v){return()=>yt(t.current,v,Ho)}function p(v){var A;o.current.has(v.key)||(o.current=ic(o.current,v.key));const Z=t.current.getState();return ct(t.current,v,Ge().early&&(A=Z.nextTree)!==null&&A!==void 0?A:Z.currentTree)}function S(v){const A=p(v);return vn(A,v,t)}function V(v){return[S(v),l(v)]}function C(v){return[p(v),l(v)]}return{getRecoilValue:S,getRecoilValueLoadable:p,getRecoilState:V,getRecoilStateLoadable:C,getSetRecoilState:l,getResetRecoilState:f}},[o,t])}const lc={current:0};function dc(e){const t=Re(),n=it(),o=se(()=>{var u;const l=t.current,f=l.getState(),p=Ge().early&&(u=f.nextTree)!==null&&u!==void 0?u:f.currentTree;return{loadable:ct(l,e,p),key:e.key}},[t,e]),r=se(u=>{let l;return()=>{var f,p;const S=u();return(f=l)!==null&&f!==void 0&&f.loadable.is(S.loadable)&&((p=l)===null||p===void 0?void 0:p.key)===S.key?l:(l=S,S)}},[]),a=qo(()=>r(o),[o,r]),s=se(u=>{const l=t.current;return Fe(l,e,u,n).release},[t,e,n]);return rc(s,a,a).loadable}function fc(e){const t=Re(),n=se(()=>{var f;const p=t.current,S=p.getState(),V=Ge().early&&(f=S.nextTree)!==null&&f!==void 0?f:S.currentTree;return ct(p,e,V)},[t,e]),o=se(()=>n(),[n]),r=it(),a=se((f,p)=>{const S=t.current;return Fe(S,e,()=>{if(!z("recoil_suppress_rerender_in_callback"))return p();const C=n();l.current.is(C)||p(),l.current=C},r).release},[t,e,r,n]),s=ac();if(s==null)throw I("Recoil hooks must be used in components contained within a <RecoilRoot> component.");const u=oc(s,o,a),l=tt(u);return xe(()=>{l.current=u}),u}function an(e){const t=Re(),n=it(),o=se(()=>{var l;const f=t.current,p=f.getState(),S=Ge().early&&(l=p.nextTree)!==null&&l!==void 0?l:p.currentTree;return ct(f,e,S)},[t,e]),r=se(()=>({loadable:o(),key:e.key}),[o,e.key]),a=se(l=>{const f=r();return l.loadable.is(f.loadable)&&l.key===f.key?l:f},[r]);xe(()=>{const l=Fe(t.current,e,f=>{u(a)},n);return u(a),l.release},[n,e,t,a]);const[s,u]=yn(r);return s.key!==e.key?r().loadable:s.loadable}function hc(e){const t=Re(),[,n]=yn([]),o=it(),r=se(()=>{var u;const l=t.current,f=l.getState(),p=Ge().early&&(u=f.nextTree)!==null&&u!==void 0?u:f.currentTree;return ct(l,e,p)},[t,e]),a=r(),s=tt(a);return xe(()=>{s.current=a}),xe(()=>{const u=t.current,l=u.getState(),f=Fe(u,e,S=>{var V;if(!z("recoil_suppress_rerender_in_callback"))return n([]);const C=r();(V=s.current)!==null&&V!==void 0&&V.is(C)||n(C),s.current=C},o);if(l.nextTree)u.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{s.current=null,n([])});else{var p;if(!z("recoil_suppress_rerender_in_callback"))return n([]);const S=r();(p=s.current)!==null&&p!==void 0&&p.is(S)||n(S),s.current=S}return f.release},[o,r,e,t]),a}function gn(e){return z("recoil_memory_managament_2020")&&Rn(e),{TRANSITION_SUPPORT:an,SYNC_EXTERNAL_STORE:nc()?dc:an,MUTABLE_SOURCE:fc,LEGACY:hc}[Ge().mode](e)}function jo(e){const t=Re(),n=gn(e);return vn(n,e,t)}function kt(e){const t=Re();return se(n=>{yt(t.current,e,n)},[t,e])}function pc(e){const t=Re();return se(()=>{yt(t.current,e,Ho)},[t,e])}function _c(e){return[jo(e),kt(e)]}function Sc(e){return[gn(e),kt(e)]}function mc(){const e=Re();return(t,n={})=>{tc(()=>{e.current.addTransactionMetadata(n),t.forEach((o,r)=>sc(e.current,new rn(r),o))})}}function Zo(e){return z("recoil_memory_managament_2020")&&Rn(e),an(e)}function Yo(e){const t=Re(),n=Zo(e);return vn(n,e,t)}function Rc(e){return[Yo(e),kt(e)]}var yc={recoilComponentGetRecoilValueCount_FOR_TESTING:lc,useRecoilInterface:uc,useRecoilState:_c,useRecoilStateLoadable:Sc,useRecoilValue:jo,useRecoilValueLoadable:gn,useResetRecoilState:pc,useSetRecoilState:kt,useSetUnvalidatedAtomValues:mc,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:Zo,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:Yo,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Rc};function vc(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n}var gc=vc;function bc(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n}var Tc=bc;function wc(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t}var Ac=wc;const{batchUpdates:Ec}=Ct,{DEFAULT_VALUE:Nc,getNode:Xo,nodes:Lc}=ie,{useStoreRef:bn}=ge,{AbstractRecoilValue:Cc,setRecoilValueLoadable:Vc}=me,{SUSPENSE_TIMEOUT_MS:$c}=$e,{cloneSnapshot:vt}=It,{useCallback:Dt,useEffect:Jo,useRef:xn,useState:Mc}=j,{isSSR:zn}=Vt;function Bt(e){const t=bn();Jo(()=>t.current.subscribeToTransactions(e).release,[e,t])}function Wn(e){const t=e.atomValues.toMap(),n=Rt(gc(t,(o,r)=>{const s=Xo(r).persistence_UNSTABLE;return s!=null&&s.type!=="none"&&o.state==="hasValue"}),o=>o.contents);return Ac(e.nonvalidatedAtoms.toMap(),n)}function Ic(e){Bt(Dt(t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(n=t.getState().currentTree);const r=Wn(o),a=Wn(n),s=Rt(Lc,l=>{var f,p,S,V;return{persistence_UNSTABLE:{type:(f=(p=l.persistence_UNSTABLE)===null||p===void 0?void 0:p.type)!==null&&f!==void 0?f:"none",backButton:(S=(V=l.persistence_UNSTABLE)===null||V===void 0?void 0:V.backButton)!==null&&S!==void 0?S:!1}}}),u=Tc(o.dirtyAtoms,l=>r.has(l)||a.has(l));e({atomValues:r,previousAtomValues:a,atomInfo:s,modifiedAtoms:u,transactionMetadata:{...o.transactionMetadata}})},[e]))}function Uc(e){Bt(Dt(t=>{const n=vt(t,"latest"),o=vt(t,"previous");e({snapshot:n,previousSnapshot:o})},[e]))}function kc(){const e=bn(),[t,n]=Mc(()=>vt(e.current)),o=Ko(t),r=xn(),a=xn();if(Bt(Dt(u=>n(vt(u)),[])),Jo(()=>{const u=t.retain();if(r.current&&!zn){var l;window.clearTimeout(r.current),r.current=null,(l=a.current)===null||l===void 0||l.call(a),a.current=null}return()=>{window.setTimeout(u,10)}},[t]),o!==t&&!zn){if(r.current){var s;window.clearTimeout(r.current),r.current=null,(s=a.current)===null||s===void 0||s.call(a),a.current=null}a.current=t.retain(),r.current=window.setTimeout(()=>{var u;r.current=null,(u=a.current)===null||u===void 0||u.call(a),a.current=null},$c)}return t}function Qo(e,t){var n;const o=e.getState(),r=(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;Ec(()=>{const s=new Set;for(const f of[r.atomValues.keys(),a.atomValues.keys()])for(const p of f){var u,l;((u=r.atomValues.get(p))===null||u===void 0?void 0:u.contents)!==((l=a.atomValues.get(p))===null||l===void 0?void 0:l.contents)&&Xo(p).shouldRestoreFromSnapshots&&s.add(p)}s.forEach(f=>{Vc(e,new Cc(f),a.atomValues.has(f)?q(a.atomValues.get(f)):Nc)}),e.replaceState(f=>({...f,stateID:t.getID()}))})}function Dc(){const e=bn();return Dt(t=>Qo(e.current,t),[e])}var er={useRecoilSnapshot:kc,gotoSnapshot:Qo,useGotoRecoilSnapshot:Dc,useRecoilTransactionObserver:Uc,useTransactionObservation_DEPRECATED:Ic,useTransactionSubscription_DEPRECATED:Bt};const{peekNodeInfo:Bc}=Te,{useStoreRef:Pc}=ge;function Oc(){const e=Pc();return({key:t})=>Bc(e.current,e.current.getState().currentTree,t)}var Fc=Oc;const{reactMode:xc}=rt,{RecoilRoot:zc,useStoreRef:Wc}=ge,{useMemo:Gc}=j;function Kc(){xc().mode==="MUTABLE_SOURCE"&&console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");const e=Wc().current;return Gc(()=>{function t({children:n}){return j.createElement(zc,{store_INTERNAL:e},n)}return t},[e])}var Hc=Kc;const{loadableWithValue:qc}=ot,{initializeNode:jc}=Te,{DEFAULT_VALUE:Zc,getNode:Yc}=ie,{copyTreeState:Xc,getRecoilValueAsLoadable:Jc,invalidateDownstreams:Qc,writeLoadableToTreeState:eu}=me;function Gn(e){return Yc(e.key).nodeType==="atom"}class tu{constructor(t,n){M(this,"_store",void 0),M(this,"_treeState",void 0),M(this,"_changes",void 0),M(this,"get",o=>{if(this._changes.has(o.key))return this._changes.get(o.key);if(!Gn(o))throw I("Reading selectors within atomicUpdate is not supported");const r=Jc(this._store,o,this._treeState);if(r.state==="hasValue")return r.contents;throw r.state==="hasError"?r.contents:I(`Expected Recoil atom ${o.key} to have a value, but it is in a loading state.`)}),M(this,"set",(o,r)=>{if(!Gn(o))throw I("Setting selectors within atomicUpdate is not supported");if(typeof r=="function"){const a=this.get(o);this._changes.set(o.key,r(a))}else jc(this._store,o.key,"set"),this._changes.set(o.key,r)}),M(this,"reset",o=>{this.set(o,Zc)}),this._store=t,this._treeState=n,this._changes=new Map}newTreeState_INTERNAL(){if(this._changes.size===0)return this._treeState;const t=Xc(this._treeState);for(const[n,o]of this._changes)eu(t,n,qc(o));return Qc(this._store,t),t}}function nu(e){return t=>{e.replaceState(n=>{const o=new tu(e,n);return t(o),o.newTreeState_INTERNAL()})}}var ou={atomicUpdater:nu},ru=ou.atomicUpdater,tr=Object.freeze({__proto__:null,atomicUpdater:ru});function au(e,t){if(!e)throw new Error(t)}var su=au,Je=su;const{atomicUpdater:iu}=tr,{batchUpdates:cu}=Ct,{DEFAULT_VALUE:uu}=ie,{useStoreRef:lu}=ge,{refreshRecoilValue:du,setRecoilValue:Kn}=me,{cloneSnapshot:fu}=It,{gotoSnapshot:hu}=er,{useCallback:pu}=j;class nr{}const _u=new nr;function or(e,t,n,o){let r=_u,a;if(cu(()=>{const u="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if(typeof t!="function")throw I(u);const l=_o({...o??{},set:(p,S)=>Kn(e,p,S),reset:p=>Kn(e,p,uu),refresh:p=>du(e,p),gotoSnapshot:p=>hu(e,p),transact_UNSTABLE:p=>iu(e)(p)},{snapshot:()=>{const p=fu(e);return a=p.retain(),p}}),f=t(l);if(typeof f!="function")throw I(u);r=f(...n)}),r instanceof nr&&Je(!1),W(r))r=r.finally(()=>{var u;(u=a)===null||u===void 0||u()});else{var s;(s=a)===null||s===void 0||s()}return r}function Su(e,t){const n=lu();return pu((...o)=>or(n.current,e,o),t!=null?[...t,n]:void 0)}var rr={recoilCallback:or,useRecoilCallback:Su};const{useStoreRef:mu}=ge,{refreshRecoilValue:Ru}=me,{useCallback:yu}=j;function vu(e){const t=mu();return yu(()=>{const n=t.current;Ru(n,e)},[e,t])}var gu=vu;const{atomicUpdater:bu}=tr,{useStoreRef:Tu}=ge,{useMemo:wu}=j;function Au(e,t){const n=Tu();return wu(()=>(...o)=>{bu(n.current)(a=>{e(a)(...o)})},t!=null?[...t,n]:void 0)}var Eu=Au;class Nu{constructor(t){M(this,"value",void 0),this.value=t}}var Lu={WrappedValue:Nu},Cu=Lu.WrappedValue,ar=Object.freeze({__proto__:null,WrappedValue:Cu});const{isFastRefreshEnabled:Vu}=rt;class Hn extends Error{}class $u{constructor(t){var n,o,r;M(this,"_name",void 0),M(this,"_numLeafs",void 0),M(this,"_root",void 0),M(this,"_onHit",void 0),M(this,"_onSet",void 0),M(this,"_mapNodeValue",void 0),this._name=t==null?void 0:t.name,this._numLeafs=0,this._root=null,this._onHit=(n=t==null?void 0:t.onHit)!==null&&n!==void 0?n:()=>{},this._onSet=(o=t==null?void 0:t.onSet)!==null&&o!==void 0?o:()=>{},this._mapNodeValue=(r=t==null?void 0:t.mapNodeValue)!==null&&r!==void 0?r:a=>a}size(){return this._numLeafs}root(){return this._root}get(t,n){var o;return(o=this.getLeafNode(t,n))===null||o===void 0?void 0:o.value}getLeafNode(t,n){if(this._root==null)return;let o=this._root;for(;o;){if(n==null||n.onNodeVisit(o),o.type==="leaf")return this._onHit(o),o;const r=this._mapNodeValue(t(o.nodeKey));o=o.branches.get(r)}}set(t,n,o){const r=()=>{var a,s,u,l;let f,p;for(const[Z,ne]of t){var S,V,C;const w=this._root;if((w==null?void 0:w.type)==="leaf")throw this.invalidCacheError();const B=f;if(f=B?B.branches.get(p):w,f=(S=f)!==null&&S!==void 0?S:{type:"branch",nodeKey:Z,parent:B,branches:new Map,branchKey:p},f.type!=="branch"||f.nodeKey!==Z)throw this.invalidCacheError();B==null||B.branches.set(p,f),o==null||(V=o.onNodeVisit)===null||V===void 0||V.call(o,f),p=this._mapNodeValue(ne),this._root=(C=this._root)!==null&&C!==void 0?C:f}const v=f?(a=f)===null||a===void 0?void 0:a.branches.get(p):this._root;if(v!=null&&(v.type!=="leaf"||v.branchKey!==p))throw this.invalidCacheError();const A={type:"leaf",value:n,parent:f,branchKey:p};(s=f)===null||s===void 0||s.branches.set(p,A),this._root=(u=this._root)!==null&&u!==void 0?u:A,this._numLeafs++,this._onSet(A),o==null||(l=o.onNodeVisit)===null||l===void 0||l.call(o,A)};try{r()}catch(a){if(a instanceof Hn)this.clear(),r();else throw a}}delete(t){const n=this.root();if(!n)return!1;if(t===n)return this._root=null,this._numLeafs=0,!0;let o=t.parent,r=t.branchKey;for(;o;){var a;if(o.branches.delete(r),o===n)return o.branches.size===0?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(o.branches.size>0)break;r=(a=o)===null||a===void 0?void 0:a.branchKey,o=o.parent}for(;o!==n;o=o.parent)if(o==null)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){const t=Vu()?"Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache.":"Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";throw cn(t+(this._name!=null?` - ${this._name}`:"")),new Hn}}var Mu={TreeCache:$u},Iu=Mu.TreeCache,sr=Object.freeze({__proto__:null,TreeCache:Iu});class Uu{constructor(t){var n;M(this,"_maxSize",void 0),M(this,"_size",void 0),M(this,"_head",void 0),M(this,"_tail",void 0),M(this,"_map",void 0),M(this,"_keyMapper",void 0),this._maxSize=t.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=(n=t.mapKey)!==null&&n!==void 0?n:o=>o}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(t){return this._map.has(this._keyMapper(t))}get(t){const n=this._keyMapper(t),o=this._map.get(n);if(o)return this.set(t,o.value),o.value}set(t,n){const o=this._keyMapper(t);this._map.get(o)&&this.delete(t);const a=this.head(),s={key:t,right:a,left:null,value:n};a?a.left=s:this._tail=s,this._map.set(o,s),this._head=s,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const t=this.tail();t&&this.delete(t.key)}delete(t){const n=this._keyMapper(t);if(!this._size||!this._map.has(n))return;const o=q(this._map.get(n)),r=o.right,a=o.left;r&&(r.left=o.left),a&&(a.right=o.right),o===this.head()&&(this._head=r),o===this.tail()&&(this._tail=a),this._map.delete(n),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}}var ku={LRUCache:Uu},Du=ku.LRUCache,ir=Object.freeze({__proto__:null,LRUCache:Du});const{LRUCache:Bu}=ir,{TreeCache:Pu}=sr;function Ou({name:e,maxSize:t,mapNodeValue:n=o=>o}){const o=new Bu({maxSize:t}),r=new Pu({name:e,mapNodeValue:n,onHit:a=>{o.set(a,!0)},onSet:a=>{const s=o.tail();o.set(a,!0),s&&r.size()>t&&r.delete(s.key)}});return r}var qn=Ou;function Se(e,t,n){if(typeof e=="string"&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if((t==null?void 0:t.allowFunctions)!==!0)throw I("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(e===null)return"null";if(typeof e!="object"){var o;return(o=JSON.stringify(e))!==null&&o!==void 0?o:""}if(W(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((r,a)=>Se(r,t,a.toString()))}]`;if(typeof e.toJSON=="function")return Se(e.toJSON(n),t,n);if(e instanceof Map){const r={};for(const[a,s]of e)r[typeof a=="string"?a:Se(a,t)]=s;return Se(r,t,n)}return e instanceof Set?Se(Array.from(e).sort((r,a)=>Se(r,t).localeCompare(Se(a,t))),t,n):Symbol!==void 0&&e[Symbol.iterator]!=null&&typeof e[Symbol.iterator]=="function"?Se(Array.from(e),t,n):`{${Object.keys(e).filter(r=>e[r]!==void 0).sort().map(r=>`${Se(r,t)}:${Se(e[r],t,r)}`).join(",")}}`}function Fu(e,t={allowFunctions:!1}){return Se(e,t)}var Pt=Fu;const{TreeCache:xu}=sr,lt={equality:"reference",eviction:"keep-all",maxSize:1/0};function zu({equality:e=lt.equality,eviction:t=lt.eviction,maxSize:n=lt.maxSize}=lt,o){const r=Wu(e);return Gu(t,n,r,o)}function Wu(e){switch(e){case"reference":return t=>t;case"value":return t=>Pt(t)}throw I(`Unrecognized equality policy ${e}`)}function Gu(e,t,n,o){switch(e){case"keep-all":return new xu({name:o,mapNodeValue:n});case"lru":return qn({name:o,maxSize:q(t),mapNodeValue:n});case"most-recent":return qn({name:o,maxSize:1,mapNodeValue:n})}throw I(`Unrecognized eviction policy ${e}`)}var Ku=zu;function Hu(e){return()=>null}var qu={startPerfBlock:Hu};const{isLoadable:ju,loadableWithError:dt,loadableWithPromise:Zu,loadableWithValue:Zt}=ot,{WrappedValue:cr}=ar,{getNodeLoadable:ft,peekNodeLoadable:Yu,setNodeValue:Xu}=Te,{saveDepsToStore:Ju}=at,{DEFAULT_VALUE:Qu,getConfigDeletionHandler:el,getNode:tl,registerNode:jn}=ie,{isRecoilValue:nl}=Oe,{markRecoilValueModified:Zn}=me,{retainedByOptionWithDefault:ol}=$e,{recoilCallback:rl}=rr,{startPerfBlock:al}=qu;class ur{}const Ze=new ur,Ye=[],ht=new Map,sl=(()=>{let e=0;return()=>e++})();function lr(e){let t=null;const{key:n,get:o,cachePolicy_UNSTABLE:r}=e,a=e.set!=null?e.set:void 0,s=new Set,u=Ku(r??{equality:"reference",eviction:"keep-all"},n),l=ol(e.retainedBy_UNSTABLE),f=new Map;let p=0;function S(){return!z("recoil_memory_managament_2020")||p>0}function V(d){return d.getState().knownSelectors.add(n),p++,()=>{p--}}function C(){return el(n)!==void 0&&!S()}function v(d,_,m,$,b){de(_,$,b),A(d,m)}function A(d,_){ce(d,_)&&Q(d),ne(_,!0)}function Z(d,_){ce(d,_)&&(q(ee(d)).stateVersions.clear(),ne(_,!1))}function ne(d,_){const m=ht.get(d);if(m!=null){for(const $ of m)Zn($,q(t));_&&ht.delete(d)}}function w(d,_){let m=ht.get(_);m==null&&ht.set(_,m=new Set),m.add(d)}function B(d,_,m,$,b,D){return _.then(k=>{if(!S())throw Q(d),Ze;const T=Zt(k);return v(d,m,b,T,$),k}).catch(k=>{if(!S())throw Q(d),Ze;if(W(k))return J(d,k,m,$,b,D);const T=dt(k);throw v(d,m,b,T,$),k})}function J(d,_,m,$,b,D){return _.then(k=>{if(!S())throw Q(d),Ze;D.loadingDepKey!=null&&D.loadingDepPromise===_?m.atomValues.set(D.loadingDepKey,Zt(k)):d.getState().knownSelectors.forEach(F=>{m.atomValues.delete(F)});const T=Y(d,m);if(T&&T.state!=="loading"){if((ce(d,b)||ee(d)==null)&&A(d,b),T.state==="hasValue")return T.contents;throw T.contents}if(!ce(d,b)){const F=ye(d,m);if(F!=null)return F.loadingLoadable.contents}const[K,te]=G(d,m,b);if(K.state!=="loading"&&v(d,m,b,K,te),K.state==="hasError")throw K.contents;return K.contents}).catch(k=>{if(k instanceof ur)throw Ze;if(!S())throw Q(d),Ze;const T=dt(k);throw v(d,m,b,T,$),k})}function x(d,_,m,$){var b,D,k,T;if(ce(d,$)||_.version===((b=d.getState())===null||b===void 0||(D=b.currentTree)===null||D===void 0?void 0:D.version)||_.version===((k=d.getState())===null||k===void 0||(T=k.nextTree)===null||T===void 0?void 0:T.version)){var K,te,F;Ju(n,m,d,(K=(te=d.getState())===null||te===void 0||(F=te.nextTree)===null||F===void 0?void 0:F.version)!==null&&K!==void 0?K:d.getState().currentTree.version)}for(const X of m)s.add(X)}function G(d,_,m){const $=al(n);let b=!0,D=!0;const k=()=>{$(),D=!1};let T,K=!1,te;const F={loadingDepKey:null,loadingDepPromise:null},X=new Map;function pe({key:fe}){const ue=ft(d,_,fe);switch(X.set(fe,ue),b||(x(d,_,new Set(X.keys()),m),Z(d,m)),ue.state){case"hasValue":return ue.contents;case"hasError":throw ue.contents;case"loading":throw F.loadingDepKey=fe,F.loadingDepPromise=ue.contents,ue.contents}throw I("Invalid Loadable state")}const Ee=fe=>(...ue)=>{if(D)throw I("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return t==null&&Je(!1),rl(d,fe,ue,{node:t})};try{T=o({get:pe,getCallback:Ee}),T=nl(T)?pe(T):T,ju(T)&&(T.state==="hasError"&&(K=!0),T=T.contents),W(T)?T=B(d,T,_,X,m,F).finally(k):k(),T=T instanceof cr?T.value:T}catch(fe){T=fe,W(T)?T=J(d,T,_,X,m,F).finally(k):(K=!0,k())}return K?te=dt(T):W(T)?te=Zu(T):te=Zt(T),b=!1,Me(d,m,X),x(d,_,new Set(X.keys()),m),[te,X]}function Y(d,_){let m=_.atomValues.get(n);if(m!=null)return m;const $=new Set;try{m=u.get(D=>(typeof D!="string"&&Je(!1),ft(d,_,D).contents),{onNodeVisit:D=>{D.type==="branch"&&D.nodeKey!==n&&$.add(D.nodeKey)}})}catch(D){throw I(`Problem with cache lookup for selector "${n}": ${D.message}`)}if(m){var b;_.atomValues.set(n,m),x(d,_,$,(b=ee(d))===null||b===void 0?void 0:b.executionID)}return m}function re(d,_){const m=Y(d,_);if(m!=null)return Q(d),m;const $=ye(d,_);if($!=null){var b;return((b=$.loadingLoadable)===null||b===void 0?void 0:b.state)==="loading"&&w(d,$.executionID),$.loadingLoadable}const D=sl(),[k,T]=G(d,_,D);return k.state==="loading"?(le(d,D,k,T,_),w(d,D)):(Q(d),de(_,k,T)),k}function ye(d,_){const m=Mo([f.has(d)?[q(f.get(d))]:[],At(hn(f,([b])=>b!==d),([,b])=>b)]);function $(b){for(const[D,k]of b)if(!ft(d,_,D).is(k))return!0;return!1}for(const b of m){if(b.stateVersions.get(_.version)||!$(b.depValuesDiscoveredSoFarDuringAsyncWork))return b.stateVersions.set(_.version,!0),b;b.stateVersions.set(_.version,!1)}}function ee(d){return f.get(d)}function le(d,_,m,$,b){f.set(d,{depValuesDiscoveredSoFarDuringAsyncWork:$,executionID:_,loadingLoadable:m,stateVersions:new Map([[b.version,!0]])})}function Me(d,_,m){if(ce(d,_)){const $=ee(d);$!=null&&($.depValuesDiscoveredSoFarDuringAsyncWork=m)}}function Q(d){f.delete(d)}function ce(d,_){var m;return _===((m=ee(d))===null||m===void 0?void 0:m.executionID)}function Ae(d){return Array.from(d.entries()).map(([_,m])=>[_,m.contents])}function de(d,_,m){d.atomValues.set(n,_);try{u.set(Ae(m),_)}catch($){throw I(`Problem with setting cache for selector "${n}": ${$.message}`)}}function ve(d){if(Ye.includes(n)){const _=`Recoil selector has circular dependencies: ${Ye.slice(Ye.indexOf(n)).join("  ")}`;return dt(I(_))}Ye.push(n);try{return d()}finally{Ye.pop()}}function Ie(d,_){const m=_.atomValues.get(n);return m??u.get($=>{var b;return typeof $!="string"&&Je(!1),(b=Yu(d,_,$))===null||b===void 0?void 0:b.contents})}function Ue(d,_){return ve(()=>re(d,_))}function P(d){d.atomValues.delete(n)}function O(d,_){t==null&&Je(!1);for(const $ of s){var m;const b=tl($);(m=b.clearCache)===null||m===void 0||m.call(b,d,_)}s.clear(),P(_),u.clear(),Zn(d,t)}return a!=null?t=jn({key:n,nodeType:"selector",peek:Ie,get:Ue,set:(_,m,$)=>{let b=!1;const D=new Map;function k({key:F}){if(b)throw I("Recoil: Async selector sets are not currently supported.");const X=ft(_,m,F);if(X.state==="hasValue")return X.contents;if(X.state==="loading"){const pe=`Getting value of asynchronous atom or selector "${F}" in a pending state while setting selector "${n}" is not yet supported.`;throw I(pe)}else throw X.contents}function T(F,X){if(b)throw I("Recoil: Async selector sets are not currently supported.");const pe=typeof X=="function"?X(k(F)):X;Xu(_,m,F.key,pe).forEach((fe,ue)=>D.set(ue,fe))}function K(F){T(F,Qu)}const te=a({set:T,get:k,reset:K},$);if(te!==void 0)throw W(te)?I("Recoil: Async selector sets are not currently supported."):I("Recoil: selector set should be a void function.");return b=!0,D},init:V,invalidate:P,clearCache:O,shouldDeleteConfigOnRelease:C,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:l}):t=jn({key:n,nodeType:"selector",peek:Ie,get:Ue,init:V,invalidate:P,clearCache:O,shouldDeleteConfigOnRelease:C,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:l})}lr.value=e=>new cr(e);var ze=lr;const{isLoadable:il,loadableWithError:Yt,loadableWithPromise:Xt,loadableWithValue:De}=ot,{WrappedValue:dr}=ar,{peekNodeInfo:cl}=Te,{DEFAULT_VALUE:Ne,DefaultValue:be,getConfigDeletionHandler:fr,registerNode:ul,setConfigDeletionHandler:ll}=ie,{isRecoilValue:dl}=Oe,{getRecoilValueAsLoadable:fl,markRecoilValueModified:hl,setRecoilValue:Yn,setRecoilValueLoadable:pl}=me,{retainedByOptionWithDefault:_l}=$e,Xe=e=>e instanceof dr?e.value:e;function Sl(e){const{key:t,persistence_UNSTABLE:n}=e,o=_l(e.retainedBy_UNSTABLE);let r=0;function a(w){return Xt(w.then(B=>(s=De(B),B)).catch(B=>{throw s=Yt(B),B}))}let s=W(e.default)?a(e.default):il(e.default)?e.default.state==="loading"?a(e.default.contents):e.default:De(Xe(e.default));s.contents;let u;const l=new Map;function f(w){return w}function p(w,B){const J=B.then(x=>{var G,Y;return((Y=((G=w.getState().nextTree)!==null&&G!==void 0?G:w.getState().currentTree).atomValues.get(t))===null||Y===void 0?void 0:Y.contents)===J&&Yn(w,ne,x),x}).catch(x=>{var G,Y;throw((Y=((G=w.getState().nextTree)!==null&&G!==void 0?G:w.getState().currentTree).atomValues.get(t))===null||Y===void 0?void 0:Y.contents)===J&&pl(w,ne,Yt(x)),x});return J}function S(w,B,J){var x;r++;const G=()=>{var ee;r--,(ee=l.get(w))===null||ee===void 0||ee.forEach(le=>le()),l.delete(w)};if(w.getState().knownAtoms.add(t),s.state==="loading"){const ee=()=>{var le;((le=w.getState().nextTree)!==null&&le!==void 0?le:w.getState().currentTree).atomValues.has(t)||hl(w,ne)};s.contents.finally(ee)}const Y=(x=e.effects)!==null&&x!==void 0?x:e.effects_UNSTABLE;if(Y!=null){let ee=function(P){if(ce&&P.key===t){const O=Q;return O instanceof be?V(w,B):W(O)?Xt(O.then(d=>d instanceof be?s.toPromise():d)):De(O)}return fl(w,P)},le=function(P){return ee(P).toPromise()},Me=function(P){var O;const d=cl(w,(O=w.getState().nextTree)!==null&&O!==void 0?O:w.getState().currentTree,P.key);return ce&&P.key===t&&!(Q instanceof be)?{...d,isSet:!0,loadable:ee(P)}:d},Q=Ne,ce=!0,Ae=!1,de=null;const ve=P=>O=>{if(ce){const d=ee(ne),_=d.state==="hasValue"?d.contents:Ne;Q=typeof O=="function"?O(_):O,W(Q)&&(Q=Q.then(m=>(de={effect:P,value:m},m)))}else{if(W(O))throw I("Setting atoms to async values is not implemented.");typeof O!="function"&&(de={effect:P,value:Xe(O)}),Yn(w,ne,typeof O=="function"?d=>{const _=Xe(O(d));return de={effect:P,value:_},_}:Xe(O))}},Ie=P=>()=>ve(P)(Ne),Ue=P=>O=>{var d;const{release:_}=w.subscribeToTransactions(m=>{var $;let{currentTree:b,previousTree:D}=m.getState();D||(D=b);const k=($=b.atomValues.get(t))!==null&&$!==void 0?$:s;if(k.state==="hasValue"){var T,K,te,F;const X=k.contents,pe=(T=D.atomValues.get(t))!==null&&T!==void 0?T:s,Ee=pe.state==="hasValue"?pe.contents:Ne;((K=de)===null||K===void 0?void 0:K.effect)!==P||((te=de)===null||te===void 0?void 0:te.value)!==X?O(X,Ee,!b.atomValues.has(t)):((F=de)===null||F===void 0?void 0:F.effect)===P&&(de=null)}},t);l.set(w,[...(d=l.get(w))!==null&&d!==void 0?d:[],_])};for(const P of Y)try{const O=P({node:ne,storeID:w.storeID,parentStoreID_UNSTABLE:w.parentStoreID,trigger:J,setSelf:ve(P),resetSelf:Ie(P),onSet:Ue(P),getPromise:le,getLoadable:ee,getInfo_UNSTABLE:Me});if(O!=null){var re;l.set(w,[...(re=l.get(w))!==null&&re!==void 0?re:[],O])}}catch(O){Q=O,Ae=!0}if(ce=!1,!(Q instanceof be)){var ye;const P=Ae?Yt(Q):W(Q)?Xt(p(w,Q)):De(Xe(Q));P.contents,B.atomValues.set(t,P),(ye=w.getState().nextTree)===null||ye===void 0||ye.atomValues.set(t,P)}}return G}function V(w,B){var J,x;return(J=(x=B.atomValues.get(t))!==null&&x!==void 0?x:u)!==null&&J!==void 0?J:s}function C(w,B){if(B.atomValues.has(t))return q(B.atomValues.get(t));if(B.nonvalidatedAtoms.has(t)){if(u!=null)return u;if(n==null)return s;const J=B.nonvalidatedAtoms.get(t),x=n.validator(J,Ne);return u=x instanceof be?s:De(x),u}else return s}function v(){u=void 0}function A(w,B,J){if(B.atomValues.has(t)){const x=q(B.atomValues.get(t));if(x.state==="hasValue"&&J===x.contents)return new Map}else if(!B.nonvalidatedAtoms.has(t)&&J instanceof be)return new Map;return u=void 0,new Map().set(t,De(J))}function Z(){return fr(t)!==void 0&&r<=0}const ne=ul({key:t,nodeType:"atom",peek:V,get:C,set:A,init:S,invalidate:v,shouldDeleteConfigOnRelease:Z,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return ne}function Tn(e){const{...t}=e,n="default"in e?e.default:new Promise(()=>{});return dl(n)?ml({...t,default:n}):Sl({...t,default:n})}function ml(e){const t=Tn({...e,default:Ne,persistence_UNSTABLE:e.persistence_UNSTABLE===void 0?void 0:{...e.persistence_UNSTABLE,validator:o=>o instanceof be?o:q(e.persistence_UNSTABLE).validator(o,Ne)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=ze({key:`${e.key}__withFallback`,get:({get:o})=>{const r=o(t);return r instanceof be?e.default:r},set:({set:o},r)=>o(t,r),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return ll(n.key,fr(e.key)),n}Tn.value=e=>new dr(e);var hr=Tn;class Rl{constructor(t){var n;M(this,"_map",void 0),M(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=(n=t==null?void 0:t.mapKey)!==null&&n!==void 0?n:o=>o}size(){return this._map.size}has(t){return this._map.has(this._keyMapper(t))}get(t){return this._map.get(this._keyMapper(t))}set(t,n){this._map.set(this._keyMapper(t),n)}delete(t){this._map.delete(this._keyMapper(t))}clear(){this._map.clear()}}var yl={MapCache:Rl},vl=yl.MapCache,gl=Object.freeze({__proto__:null,MapCache:vl});const{LRUCache:Xn}=ir,{MapCache:bl}=gl,pt={equality:"reference",eviction:"none",maxSize:1/0};function Tl({equality:e=pt.equality,eviction:t=pt.eviction,maxSize:n=pt.maxSize}=pt){const o=wl(e);return Al(t,n,o)}function wl(e){switch(e){case"reference":return t=>t;case"value":return t=>Pt(t)}throw I(`Unrecognized equality policy ${e}`)}function Al(e,t,n){switch(e){case"keep-all":return new bl({mapKey:n});case"lru":return new Xn({mapKey:n,maxSize:q(t)});case"most-recent":return new Xn({mapKey:n,maxSize:1})}throw I(`Unrecognized eviction policy ${e}`)}var pr=Tl;const{setConfigDeletionHandler:El}=ie;function Nl(e){var t,n;const o=pr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a,s;const u=o.get(r);if(u!=null)return u;const{cachePolicyForParams_UNSTABLE:l,...f}=e,p="default"in e?e.default:new Promise(()=>{}),S=hr({...f,key:`${e.key}__${(a=Pt(r))!==null&&a!==void 0?a:"void"}`,default:typeof p=="function"?p(r):p,retainedBy_UNSTABLE:typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE,effects:typeof e.effects=="function"?e.effects(r):typeof e.effects_UNSTABLE=="function"?e.effects_UNSTABLE(r):(s=e.effects)!==null&&s!==void 0?s:e.effects_UNSTABLE});return o.set(r,S),El(S.key,()=>{o.delete(r)}),S}}var Ll=Nl;const{setConfigDeletionHandler:Cl}=ie;let Vl=0;function $l(e){var t,n;const o=pr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a;let s;try{s=o.get(r)}catch(V){throw I(`Problem with cache lookup for selector ${e.key}: ${V.message}`)}if(s!=null)return s;const u=`${e.key}__selectorFamily/${(a=Pt(r,{allowFunctions:!0}))!==null&&a!==void 0?a:"void"}/${Vl++}`,l=V=>e.get(r)(V),f=e.cachePolicy_UNSTABLE,p=typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE;let S;if(e.set!=null){const V=e.set;S=ze({key:u,get:l,set:(v,A)=>V(r)(v,A),cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:p})}else S=ze({key:u,get:l,cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:p});return o.set(r,S),Cl(S.key,()=>{o.delete(r)}),S}}var we=$l;const Ml=we({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});function Il(e){return Ml(e)}var Ul=Il;const kl=we({key:"__error",get:e=>()=>{throw I(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});function Dl(e){return kl(e)}var Bl=Dl;function Pl(e){return e}var Ol=Pl;const{loadableWithError:_r,loadableWithPromise:Sr,loadableWithValue:mr}=ot;function Ot(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[r,a]of t.entries())try{n[r]=e(a)}catch(s){o[r]=s}return[n,o]}function Fl(e){return e!=null&&!W(e)}function Ft(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function sn(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((n,o,r)=>({...n,[o]:t[r]}),{})}function Be(e,t,n){const o=n.map((r,a)=>r==null?mr(t[a]):W(r)?Sr(r):_r(r));return sn(e,o)}function xl(e,t){return t.map((n,o)=>n===void 0?e[o]:n)}const zl=we({key:"__waitForNone",get:e=>({get:t})=>{const n=Ft(e),[o,r]=Ot(t,n);return Be(e,o,r)},dangerouslyAllowMutability:!0}),Wl=we({key:"__waitForAny",get:e=>({get:t})=>{const n=Ft(e),[o,r]=Ot(t,n);return r.some(a=>!W(a))?Be(e,o,r):new Promise(a=>{for(const[s,u]of r.entries())W(u)&&u.then(l=>{o[s]=l,r[s]=void 0,a(Be(e,o,r))}).catch(l=>{r[s]=l,a(Be(e,o,r))})})},dangerouslyAllowMutability:!0}),Gl=we({key:"__waitForAll",get:e=>({get:t})=>{const n=Ft(e),[o,r]=Ot(t,n);if(r.every(s=>s==null))return sn(e,o);const a=r.find(Fl);if(a!=null)throw a;return Promise.all(r).then(s=>sn(e,xl(o,s)))},dangerouslyAllowMutability:!0}),Kl=we({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=Ft(e),[o,r]=Ot(t,n);return r.every(a=>!W(a))?Be(e,o,r):Promise.all(r.map((a,s)=>W(a)?a.then(u=>{o[s]=u,r[s]=void 0}).catch(u=>{o[s]=void 0,r[s]=u}):null)).then(()=>Be(e,o,r))},dangerouslyAllowMutability:!0}),Hl=we({key:"__noWait",get:e=>({get:t})=>{try{return ze.value(mr(t(e)))}catch(n){return ze.value(W(n)?Sr(n):_r(n))}},dangerouslyAllowMutability:!0});var ql={waitForNone:zl,waitForAny:Wl,waitForAll:Gl,waitForAllSettled:Kl,noWait:Hl};const{RecoilLoadable:jl}=ot,{DefaultValue:Zl}=ie,{RecoilRoot:Yl,useRecoilStoreID:Xl}=ge,{isRecoilValue:Jl}=Oe,{retentionZone:Ql}=Nt,{freshSnapshot:ed}=It,{useRecoilState:td,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:nd,useRecoilStateLoadable:od,useRecoilValue:rd,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:ad,useRecoilValueLoadable:sd,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:id,useResetRecoilState:cd,useSetRecoilState:ud}=yc,{useGotoRecoilSnapshot:ld,useRecoilSnapshot:dd,useRecoilTransactionObserver:fd}=er,{useRecoilCallback:hd}=rr,{noWait:pd,waitForAll:_d,waitForAllSettled:Sd,waitForAny:md,waitForNone:Rd}=ql;var wn={DefaultValue:Zl,isRecoilValue:Jl,RecoilLoadable:jl,RecoilEnv:We,RecoilRoot:Yl,useRecoilStoreID:Xl,useRecoilBridgeAcrossReactRoots_UNSTABLE:Hc,atom:hr,selector:ze,atomFamily:Ll,selectorFamily:we,constSelector:Ul,errorSelector:Bl,readOnlySelector:Ol,noWait:pd,waitForNone:Rd,waitForAny:md,waitForAll:_d,waitForAllSettled:Sd,useRecoilValue:rd,useRecoilValueLoadable:sd,useRecoilState:td,useRecoilStateLoadable:od,useSetRecoilState:ud,useResetRecoilState:cd,useGetRecoilValueInfo_UNSTABLE:Fc,useRecoilRefresher_UNSTABLE:gu,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:id,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:ad,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:nd,useRecoilCallback:hd,useRecoilTransaction_UNSTABLE:Eu,useGotoRecoilSnapshot:ld,useRecoilSnapshot:dd,useRecoilTransactionObserver_UNSTABLE:fd,snapshot_UNSTABLE:ed,useRetain:Rn,retentionZone:Ql},wd=wn.RecoilRoot,yd=wn.atom,vd=wn.useRecoilState,St=(e=>(e.DARK="dark",e.LIGHT="light",e))(St||{});const gd=yd({key:"theme-mode-state",default:"dark",effects:[bd]});function bd({setSelf:e,onSet:t}){const n=localStorage.getItem("theme-mode");n&&e(n),t(o=>localStorage.setItem("theme-mode",o))}function Ad(){const[e,t]=vd(gd),n=Cn.useCallback(()=>{t(r=>r===St.DARK?St.LIGHT:St.DARK)},[t]),o=Cn.useMemo(()=>({toggle:n}),[n]);return[e,o]}export{wd as R,yd as a,vd as b,Ad as u};
